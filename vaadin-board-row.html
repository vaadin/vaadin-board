<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="vaadin-board-row">
  <template>
    <style>
       :host {
        display: grid;
        display: -ms-grid;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        -ms-grid-columns: 1fr 1fr 1fr 1fr;
      }

      :host(.one-column) {
        grid-template-columns: 1fr;
        -ms-grid-columns: 1fr;
      }

      :host(.two-columns) {
        grid-template-columns: 1fr 1fr;
        -ms-grid-columns: 1fr 1fr;
      }

      :host(.three-columns) {
        grid-template-columns: 1fr 1fr 1fr;
        -ms-grid-columns: 1fr 1fr 1fr;
      }

      :host(.four-columns) {
        grid-template-columns: 1fr 1fr 1fr 1fr;
        -ms-grid-columns: 1fr 1fr 1fr 1fr;
      }

       :host ::slotted(*) {
        box-sizing: border-box;
        overflow: hidden;
      }
    </style>
    <slot id="insertionPoint"></slot>
  </template>

  <script>
    (function () {
      /**
       * `<vaadin-board-row>` is a Polymer element that together with `vaadin-board` element allows to create 
       * flexible responsive layouts and build nice looking dashboard.
       * Each Row consists of four columns, and can contain up to four components
       * taking one column each, or fewer components with multiple columns each as
       * long as sum of columns stays less than or equal to four.
       *
       * @memberof Vaadin
       * @demo demo/index.html
       */
      class BoardRowElement extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
        static get is() {
          return "vaadin-board-row";
        }
        constructor() {
          super();
          this._onIronResize = this._onIronResize.bind(this);
          this._ONE_COLUMN_MAX_WIDTH = 600;
          this._TWO_COLUMNS_MAX_WIDTH = 960;

          this._SMALL_VIEWPORT_CLASSNAME = "small";
          this._MEDIUM_VIEWPORT_CLASSNAME = "medium";
          this._LARGE_VIEWPORT_CLASSNAME = "large";

          this._oldWidth = 0;
          this._oldFlexBasis = [];
        }
        ready() {
          super.ready();
          this.addEventListener('iron-resize', this._onIronResize, true);
          this.$.insertionPoint.addEventListener('slotchange', this.redraw.bind(this));
          Polymer.RenderStatus.afterNextRender(this, function () {
            //force this as an interested resizable of parent
            this.dispatchEvent(new CustomEvent('iron-request-resize-notifications', {
              node: this,
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: {}
            }));
          });
        }
        connectedCallback() {
          super.connectedCallback();
          Polymer.RenderStatus.afterNextRender(this, this._onIronResize);
        }

        /**
         * Adds styles for board row based on width
         */
        _addStyleNames(width) {
          if (width < this._ONE_COLUMN_MAX_WIDTH) {
            this.classList.add(this._SMALL_VIEWPORT_CLASSNAME);
            this.classList.remove(this._MEDIUM_VIEWPORT_CLASSNAME);
            this.classList.remove(this._LARGE_VIEWPORT_CLASSNAME);
          } else if (width < this._TWO_COLUMNS_MAX_WIDTH) {
            this.classList.remove(this._SMALL_VIEWPORT_CLASSNAME);
            this.classList.add(this._MEDIUM_VIEWPORT_CLASSNAME);
            this.classList.remove(this._LARGE_VIEWPORT_CLASSNAME);
          } else {
            this.classList.remove(this._SMALL_VIEWPORT_CLASSNAME);
            this.classList.remove(this._MEDIUM_VIEWPORT_CLASSNAME);
            this.classList.add(this._LARGE_VIEWPORT_CLASSNAME);
          }
        }

        _reportError() {
          const errorMessage = "The column configuration is not valid; column count should add up to 3 or 4.";
          console.warn(errorMessage, "check: \r\n" + this.outerHTML);
        }

        /**
         * Parses board-cols from DOM.
         * If there is not enough space in the row drop board cols.
         * @param{Array} array of nodes
         *
         * @return{Array} array of boardCols
         */
        _parseBoardCols(nodes) {
          const boardCols = nodes.map(node => {
            if (node.getAttribute("board-cols")) {
              return parseInt(node.getAttribute("board-cols"));
            }
            return 1;
          });

          let spaceLeft = 4;
          let returnBoardCols = [];
          nodes.forEach((node, i) => {
            spaceLeft = spaceLeft - boardCols[i];
          });

          if (spaceLeft < 0) {
            this._reportError();
            boardCols.forEach((node, i) => {
              returnBoardCols[i] = 1;
            });
          }
          else {
            returnBoardCols = boardCols.slice(0);
          }

          return returnBoardCols;
        }
        /**
         * If there is not enough space in the row.
         * Extra items are dropped from DOM.
         * @param{Array} array of board-cols for every node
         * @param{Array} array of nodes
         *
         * @return{Array} filtered array of nodes
         */
        _removeExtraNodesFromDOM(boardCols, nodes) {
          let isErrorReported = false;
          let spaceLeft = 4;
          let returnNodes = [];
          nodes.forEach((node, i) => {
            spaceLeft = spaceLeft - boardCols[i];
            if (spaceLeft < 0) {
              if (!isErrorReported) {
                isErrorReported = true;
                this._reportError();
              }
              this.removeChild(node);
            }
            else {
              returnNodes[i] = node;
            }
          });
          return returnNodes;
        }

        redraw() {
          this._recalculateItemSizes(true);
        }

        _onIronResize() {
          this._recalculateItemSizes(false);
        }

        _recalculateItemSizes(forceResize) {
          const width = this.getBoundingClientRect().width;
          if (forceResize || width != this._oldWidth) {
            const nodes = this.$.insertionPoint.assignedNodes({ flatten: true });
            const isElementNode = function (node) {
              return !((node.nodeType === node.TEXT_NODE)
                || (node instanceof Polymer.DomRepeat)
                || (node instanceof Polymer.DomIf));
            }
            this._addStyleNames(width);

            const filteredNodes = nodes.filter(isElementNode);
            const boardCols = this._parseBoardCols(filteredNodes);
            var colsInRow = boardCols.reduce((a, b) => a + b, 0);
            if (width < this._ONE_COLUMN_MAX_WIDTH) {
                colsInRow = 1;
              } else if (width < this._TWO_COLUMNS_MAX_WIDTH && colsInRow == 4) {
                colsInRow = 2;
              }
            this._setColumns(colsInRow);
            var spaceUsedSoFar = 0;
            this._removeExtraNodesFromDOM(boardCols, filteredNodes).forEach((e, i) => {
              
              var itemSize = boardCols[i];
              let nextItemSize = boardCols[i+1];
              let placesLeft = colsInRow - (spaceUsedSoFar % colsInRow);
              
              // an item can't take more columns than columns in a row
              if(itemSize > colsInRow){
                itemSize = colsInRow;
              }
              
              // If there is space on current row, but next item won't fit in, then expand the 
              // current item to take the rest of the space available in current row.
              // Ie. 1-2-1 spans in two column size. second item won't fit to first row so expand
              // first item to take the full row.
              if (nextItemSize != null && itemSize < placesLeft && itemSize+nextItemSize > placesLeft) {
                itemSize = placesLeft;
              }
              // If current item is the last in the row, and there is an empty space, expand
              // it to take the whole row.
              // Ie. 1-2-1 span. Last item is empty on the last row as second row needs an own
              // row. Therefore last item should not only take first column of whole row, but
              // expand to full row.
              if (nextItemSize == null && itemSize < placesLeft){
                itemSize = placesLeft
              }
              
              if (itemSize > 1) {
                e.style.gridColumnEnd = "span " + itemSize;
              } else {
                e.style.gridColumnEnd = "";
              }

              // IE10, IE11 and Edge has an old, older implementation of the CSS Grid spec.
              // That spec does not include auto placement, so each item needs to have 
              // column and row defined. Remove this when Edge has implemented current
              // support and we do not support IE10 / IE 11 anymore.
              e.style.msGridColumn = (spaceUsedSoFar % colsInRow)+1;
              e.style.msGridRow = Math.floor(spaceUsedSoFar / colsInRow)+1;
              if (itemSize > 1) {
                e.style.msGridColumnSpan = itemSize;
              } else {
                e.style.msGridColumnSpan = "";
              }
              
              //save for next iteration
              spaceUsedSoFar = spaceUsedSoFar + itemSize;
            });    
            this._oldWidth = width;
          }
        }

        _setColumns(columns) {
          this.classList.remove("one-column");
          this.classList.remove("two-columns");
          this.classList.remove("three-columns");
          this.classList.remove("four-columns");
          switch (columns) {
            case 1: this.classList.add("one-column"); break;
            case 2: this.classList.add("two-columns"); break;
            case 3: this.classList.add("three-columns"); break;
            case 4:
            default: this.classList.add("four-columns"); break;
          }
        }
      }
      customElements.define(BoardRowElement.is, BoardRowElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin = window.Vaadin || {};
      window.Vaadin.BoardRowElement = BoardRowElement;
    })();
  </script>
</dom-module>